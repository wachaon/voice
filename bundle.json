{
  "{F0EC8036-3971-4DE5-AD06-522F08905294}": {
    "source": "// imports built-ins\r\nconst { httprequest } = require('httprequest')\r\n\r\n// imports libraries\r\nconst compile = require('./lib/compile')\r\nconst { getDict, setDict, deleteDict } = require('./lib/dict')\r\nconst genQuery = require('./lib/genQuery')\r\nconst genWav = require('./lib/genWav')\r\nconst getProcess = require('./lib/getProcess')\r\nconst { getVoices, getVoiceID } = require('./lib/getVoices')\r\nconst request = require('./lib/request')\r\nconst { getServer, initServer, serverError } = require('./lib/server')\r\nconst speach = require('./lib/speach')\r\nconst speak = require('./lib/speak')\r\n\r\n// exports\r\nmodule.exports = {\r\n    compile,\r\n    getDict,\r\n    setDict,\r\n    deleteDict,\r\n    genQuery,\r\n    genWav,\r\n    getProcess,\r\n    getVoices,\r\n    getVoiceID,\r\n    getServer,\r\n    initServer,\r\n    request,\r\n    serverError,\r\n    speach,\r\n    speak,\r\n}\r\n",
    "mapping": {
      "./lib/compile": "{5A2EB31D-C6DA-453C-BA3E-E0DD66F98E69}",
      "./lib/dict": "{56CF9F5F-9FAB-43C0-9547-B0B7F1DC9273}",
      "./lib/genQuery": "{FA69E22A-086A-4299-A5E4-3DD325B9131E}",
      "./lib/genWav": "{E7B6D35C-36AA-497B-863E-A35AC5A8BE6F}",
      "./lib/getVoices": "{A129D0C3-5203-49A9-8059-374AB359B604}",
      "./lib/speach": "{20049F22-5DC7-401D-98FF-3D55F0122BC1}",
      "./lib/speak": "{B5FAD3FA-C939-4ED0-982B-663CDCC2FB11}"
    },
    "path": "{voice}/index.js"
  },
  "{23503729-88A6-4A27-A9AC-F071B9BF6848}": {
    "source": "{\n  \"name\": \"voice\",\n  \"version\": \"0.0.2\",\n  \"description\": \"Handling audio with wes\",\n  \"main\": \"index.js\",\n  \"directories\": {\n    \"lib\": \"lib\"\n  },\n  \"scripts\": {\n    \"test\": \"wes usage\",\n    \"bundle\": \"wes bundle /player.cs /voices.js\"\n  },\n  \"keywords\": [\n    \"SAPI.SpVoice\",\n    \"VOICEVOX\"\n  ],\n  \"author\": \"wachaon\",\n  \"license\": \"MIT\"\n}",
    "mapping": {},
    "path": "{voice}/package.json"
  },
  "{5A2EB31D-C6DA-453C-BA3E-E0DD66F98E69}": {
    "source": "// imports built-ins\r\nconst { SPACE } = require('text')\r\nconst { search } = require('match')\r\n\r\n// imports libraries\r\nconst execute = require('./execute')\r\n\r\n// constant\r\nconst compiler = getCompiler()\r\n\r\n// exports\r\nmodule.exports = compile\r\n\r\n/**\r\n * Compile C#.\r\n * @example\r\n * compile('player.cs', { target: 'exe', out: 'player.exe' })\r\n * @param {string} path\r\n * @param {Object<string, string>} options\r\n */\r\nfunction compile(path, options = {}) {\r\n    let opts = []\r\n    Object.keys(options).forEach(key => {\r\n        const value = options[key]\r\n        opts.push(`/${key}:${value}`)\r\n    })\r\n    const command = `${compiler} ${opts.join(SPACE)} ${path}`\r\n    console.log(() => command)\r\n    execute(`${command}`, `${path} compiling`)\r\n}\r\n\r\n// util\r\n/**\r\n * Returns the path of the included csc.exe.\r\n * @returns {string}\r\n */\r\nfunction getCompiler() {\r\n    return search('**/csc.exe', 'C:/Windows/Microsoft.NET/Framework').slice(-1)[0]\r\n}",
    "mapping": {
      "./execute": "{7C64E4F2-F75D-4424-BDA1-12661E9E411F}"
    },
    "path": "{voice}/lib/compile.js"
  },
  "{7C64E4F2-F75D-4424-BDA1-12661E9E411F}": {
    "source": "// imports OLE\r\nconst WShell = require('WScript.Shell')\r\n\r\n// exports\r\nmodule.exports = execute\r\n\r\n/**\r\n * Run the program in command prompt.\r\n * @example\r\n * execute('dir', 'Get file list')\r\n * @param {String} cmd\r\n * @param {String?} message\r\n */\r\nfunction execute(cmd, message = 'execte command') {\r\n    const exec = WShell.Exec(`cmd /c ${cmd}`)\r\n\r\n    let counter = 0\r\n    const indicator = ['|', '/', '-', '\\\\',]\r\n    const rotation = indicator.length\r\n\r\n    while (exec.Status == 0) {\r\n        console.weaklog(`${indicator[counter++ % rotation]} ${message}`)\r\n        WScript.Sleep(50)\r\n    }\r\n\r\n    const error = exec.StdErr.ReadAll()\r\n    if (error) console.error(error)\r\n    else console.log(exec.StdOut.ReadAll())\r\n}",
    "mapping": {},
    "path": "{voice}/lib/execute.js"
  },
  "{56CF9F5F-9FAB-43C0-9547-B0B7F1DC9273}": {
    "source": "// imports built-ins\r\nconst { httprequest } = require('httprequest')\r\n\r\n// imports libraries\r\nconst { initServer, getServer, serverError } = require('./server')\r\n\r\n// exports\r\nmodule.exports = {\r\n    getDict,\r\n    setDict,\r\n    deleteDict\r\n}\r\n\r\n/**\r\n * Get list of dictionaries\r\n * @returns {Dict[]}\r\n */\r\nfunction getDict() {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    return JSON.parse(httprequest('GET', 'http://127.0.0.1:50021/user_dict', { accept: \"application/json\" }).responseText)\r\n}\r\n\r\n/** @typedef {Number} Int */\r\n\r\n/**\r\n * @typedef {Object} Dict\r\n * @property {String} surface\r\n * @property {String} pronunciation\r\n * @property {Int} accent_type\r\n * @property {\"PROPER_NOUN\"|\"COMMON_NOUN\"|\"VERB\"|\"ADJECTIVE\"|\"SUFFIX\"} [word_type] PROPER_NOUN(固有名詞) COMMON_NOUN(普通名詞) VERB(動詞) ADJECTIVE(形容詞) SUFFIX(語尾\r\n * @property {Int?} priority - from 0 to 10\r\n */\r\n\r\n/**\r\n * Register in dictionary\r\n * @example\r\n * setDictionary({\r\n *   surface: '高品質',\r\n *   pronunciation: 'コウヒンシツ',\r\n *   accent_type: 1,\r\n *   word_type: 'ADJECTIVE()\r\n *   priority: 5\r\n * })\r\n * @param {Dict} dict\r\n */\r\nfunction setDict(dict) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    dict.surface = encodeURI(dict.surface)\r\n    dict.pronunciation = encodeURI(dict.pronunciation)\r\n    let params = Object\r\n        .keys(dict)\r\n        .map(key => `${key}=${dict[key]}`)\r\n        .join('&')\r\n    httprequest('POST', `http://127.0.0.1:50021/user_dict_word?${params}`, { accept: \"application/json\" }).responseText\r\n}\r\n\r\n/**\r\n * Cancel dictionary registration\r\n * @param {String} uuid\r\n */\r\nfunction deleteDict(uuid) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    httprequest('DELETE', `http://127.0.0.1:50021/user_dict_word?${uuid}`)\r\n}",
    "mapping": {
      "./server": "{8F1DDFC2-53A5-41E9-8F29-37918D97CA65}"
    },
    "path": "{voice}/lib/dict.js"
  },
  "{8F1DDFC2-53A5-41E9-8F29-37918D97CA65}": {
    "source": "// imports OLE\r\nconst WShell = require('WScript.Shell')\r\n\r\n// imports libraries\r\nconst getProcess = require('./getProcess')\r\n\r\n// constant\r\nconst USERNAME = WShell.ExpandEnvironmentStrings(\"%USERNAME%\")\r\nconst run_exe = `C:\\\\Users\\\\${USERNAME}\\\\AppData\\\\Local\\\\Programs\\\\VOICEVOX\\\\run.exe`\r\nconst voicevox_exe = `C:\\\\Users\\\\${USERNAME}\\\\AppData\\\\Local\\\\Programs\\\\VOICEVOX\\\\VOICEVOX.exe`\r\nconst serverError = new Error('This module requires voicevox')\r\n\r\n// exports\r\nmodule.exports = {\r\n    getServer,\r\n    initServer,\r\n    serverError\r\n}\r\n\r\n/** @typedef {Object<string, value>} SWbemObjectEx */\r\n\r\n/**\r\n * Make sure Voicevox is running\r\n * @returns {SWbemObjectEx?}\r\n */\r\nfunction getServer() {\r\n    return getProcess(run_exe, voicevox_exe)\r\n}\r\n\r\n/**\r\n * Run Voicevox\r\n * @returns {SWbemObjectEx}\r\n */\r\nfunction initServer() {\r\n    if (!getServer()) {\r\n        WShell.Run(run_exe)\r\n\r\n        let counter = 0\r\n        const indicator = ['|', '/', '-', '\\\\',]\r\n        const rotation = indicator.length\r\n\r\n        while (!getServer()) {\r\n            console.weaklog(`${indicator[counter++ % rotation]} initialize Server`)\r\n            WScript.Sleep(50)\r\n        }\r\n    }\r\n    return getServer()\r\n}",
    "mapping": {
      "./getProcess": "{73E2A907-CD02-43A1-B028-DF48A5620117}"
    },
    "path": "{voice}/lib/server.js"
  },
  "{73E2A907-CD02-43A1-B028-DF48A5620117}": {
    "source": "// imports OLE\r\nvar SWbemLocator = require(\"WbemScripting.SWbemLocator\")\r\n\r\n// imports built-ins\r\nconst { Enumerator } = require('JScript')\r\n\r\n// exports\r\nmodule.exports = getProcess\r\n\r\n/** @typedef {String} Path */\r\n/** @typedef {Object<string, value>} SWbemObjectEx */\r\n\r\n/**\r\n * Checks if the program on the path is running and returns the process if it is.\r\n * @example\r\n * const server = getProcess(voicevox_exe, run_exe)\r\n * if (server) {\r\n *    console.log(() => server.ExecutablePath)\r\n * }\r\n * @param  {...Path} processPaths\r\n * @returns {SWbemObjectEx?}\r\n */\r\nfunction getProcess(...processPaths) {\r\n    const SWbemServicesEx = SWbemLocator.ConnectServer()\r\n    const SWbemObjectSet = SWbemServicesEx.ExecQuery(\"Select * From Win32_Process\")\r\n    const SWbemObjectExs = new Enumerator(SWbemObjectSet)\r\n\r\n    const proc = SWbemObjectExs.find(SWbemObjectEx => {\r\n        return processPaths.some(path => SWbemObjectEx.ExecutablePath === path)\r\n    })\r\n\r\n    return proc\r\n}\r\n",
    "mapping": {},
    "path": "{voice}/lib/getProcess.js"
  },
  "{FA69E22A-086A-4299-A5E4-3DD325B9131E}": {
    "source": "// imports libraries\r\nconst request = require('./request')\r\nconst { initServer, getServer, serverError } = require('./server')\r\n\r\n// exports\r\nmodule.exports = genQuery\r\n\r\n/** @typedef {Object<string, value>} Json */\r\n/** @typedef {Number} Int */\r\n\r\n/**\r\n * Generates a query object for VOICEVOX\r\n * @example\r\n * genQuery('僕はずんだの妖精なのだ', 1)\r\n * @param {String} content\r\n * @param {Int} [speaker=1] - voice id\r\n * @returns {Json}\r\n */\r\nfunction genQuery(content, speaker = 1) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    return request('POST', \"audio_query\", {\r\n        params: {\r\n            text: encodeURI(content),\r\n            speaker,\r\n        },\r\n        headers: {\r\n            accept: 'application/json'\r\n        }\r\n    })\r\n}",
    "mapping": {
      "./request": "{997B5A20-3806-4AB3-805A-85E562904BD7}"
    },
    "path": "{voice}/lib/genQuery.js"
  },
  "{997B5A20-3806-4AB3-805A-85E562904BD7}": {
    "source": "// imports OLE\r\nconst getHttpServer = require('./getHttpServer')\r\nconst IServerXMLHTTPRequest2 = getHttpServer()\r\n\r\n// import librarise\r\nconst { initServer, getServer, serverError } = require('./server')\r\n\r\nmodule.exports = request\r\n\r\n/**\r\n * @typedef {Object} RequestOptions\r\n * @property {Object<string, value>} [param]\r\n * @property {Object<string, value>} [headers]\r\n * @property {Object<string, value>} [body]\r\n */\r\n\r\n/** @typedef {Int[]} Buffer */\r\n/** @typedef {Object<string, value>} Json */\r\n\r\n/**\r\n * Request to VOICEVOX ENGINE.\r\n * @param {\"GET\"|\"POST\"|\"PUT\"|\"DELETE\"} method\r\n * @param {String} endpoint\r\n * @param {RequestOptions?} options\r\n * @returns {Buffer|Json}\r\n */\r\nfunction request(method, endpoint, options = {}) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    let params = 'params' in options ? '?' + Object\r\n        .keys(options.params)\r\n        .map(key => `${key}=${options.params[key]}`)\r\n        .join('&')\r\n        : ''\r\n    const req = `http://127.0.0.1:50021/${endpoint}${params}`\r\n\r\n    IServerXMLHTTPRequest2.open(method, req, false)\r\n    if ('headers' in options) Object\r\n        .keys(options.headers)\r\n        .forEach(header => IServerXMLHTTPRequest2.setRequestHeader(header, options.headers[header]))\r\n    IServerXMLHTTPRequest2.send('body' in options ? options.body : undefined)\r\n\r\n    let counter = 0\r\n    const indicator = ['|', '/', '-', '\\\\',]\r\n    const rotation = indicator.length\r\n    const state = ['UNSENT', 'OPENED', 'HEADERS_RECEIVED', 'LOADING', 'DONE']\r\n\r\n    while (IServerXMLHTTPRequest2.readyState != 4) {\r\n        console.weaklog(`${req.length > 50 ? req.slice(0, 30) + ' ... ' + req.slice(-10) : req} ${indicator[counter++ % rotation]} ${state[IServerXMLHTTPRequest2.readyState]}`)\r\n        WScript.Sleep(50)\r\n    }\r\n\r\n\r\n    if ('headers' in options && 'accept' in options.headers) {\r\n        if (options.headers.accept === 'application/json') return JSON.parse(IServerXMLHTTPRequest2.responseText)\r\n        return Buffer.from(IServerXMLHTTPRequest2.responseBody)\r\n    }\r\n    return IServerXMLHTTPRequest2.responseText\r\n}\r\n\r\n/*\r\nconst json = request('POST', 'audio_query', {\r\n    params: {\r\n        text: encodeURI('ずんだもんなのだ'),\r\n        speaker: 1\r\n    },\r\n    headers: {\r\n        accept: 'application/json'\r\n    }\r\n})\r\n\r\nconst response = request('POST', 'synthesis', {\r\n    params: {\r\n        text: encodeURI('ずんだもんなのだ'),\r\n        speaker: 1\r\n    },\r\n    headers: {\r\n        accept: 'audio/wav',\r\n        'Content-type': 'application/json'\r\n    },\r\n    body: JSON.stringify(json)\r\n})\r\nconsole.log(() => require('filesystem').writeFileSync('test.wav', response))\r\n*/",
    "mapping": {
      "./getHttpServer": "{4866CD8C-2636-43ED-95F4-EA4CD1A8CF8E}"
    },
    "path": "{voice}/lib/request.js"
  },
  "{4866CD8C-2636-43ED-95F4-EA4CD1A8CF8E}": {
    "source": "// imports OLE\r\nconst IServerXMLHTTPRequest2 = getHttpServer()\r\n\r\n// exports\r\nmodule.exports = getHttpServer\r\n\r\n/**\r\n * @typedef {Object<string, value>} IServerXMLHTTPRequest2\r\n */\r\n\r\n/**\r\n * Returns the path of the included IServerXMLHTTPRequest2.\r\n * @returns {IServerXMLHTTPRequest2}\r\n */\r\nfunction getHttpServer() {\r\n    let result\r\n    let names = [\r\n        'MSXML2.ServerXMLHTTP.6.0',\r\n        'MSXML2.ServerXMLHTTP.3.0',\r\n        'MSXML2.ServerXMLHTTP',\r\n        'MSXML2.XMLHTTP.6.0',\r\n        'MSXML2.XMLHTTP.3.0',\r\n        'MSXML2.XMLHTTP',\r\n        'Microsoft.XMLHTTP'\r\n    ]\r\n    names.find((name) => {\r\n        try {\r\n            result = require(name)\r\n            return true\r\n        } catch (e) {\r\n            return false\r\n        }\r\n    })\r\n    return result\r\n}\r\n",
    "mapping": {},
    "path": "{voice}/lib/getHttpServer.js"
  },
  "{E7B6D35C-36AA-497B-863E-A35AC5A8BE6F}": {
    "source": "// imports built-ins\r\nconst { writeFileSync, existsFileSync, deleteFileSync } = require('filesystem')\r\nconst { resolve } = require('pathname')\r\n\r\n// imports libraries\r\nconst { initServer, getServer, serverError } = require('./server')\r\nconst request = require('./request')\r\n\r\n// exports\r\nmodule.exports = genWav\r\n\r\n/** @typedef {Number} Int */\r\n/** @typedef {String} Path */\r\n/** @typedef {Object<string, value>} Json */\r\n/** @typedef {String} JsonString */\r\n\r\n/**\r\n * @typedef {Object} GenWavOptions\r\n * @property {Int} speaker\r\n * @property {Path} out\r\n */\r\n\r\n/**\r\n * Generate audio files from query objects\r\n * @example\r\n * const query = readFileSync('query.json', 'UTF-8')\r\n * genWav(query, { out: 'res.wav' })\r\n * @param {Json|JsonString} query\r\n * @param {GenWavOptions?} options\r\n */\r\nfunction genWav(query, options) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    /** @type {Json} */\r\n    const _query = typeof query === 'string' ? query : JSON.stringify(query)\r\n    let { speaker = 1, out = 'voice.wav' } = options\r\n\r\n    const result = request('POST', 'synthesis', {\r\n        params: {\r\n            speaker\r\n        },\r\n        headers: {\r\n            'Content-type': 'application/json',\r\n            accept: 'audeo/wav'\r\n        },\r\n        body: _query\r\n    })\r\n\r\n    const dist = resolve(process.cwd(), out)\r\n    if (existsFileSync(dist)) deleteFileSync(dist)\r\n    console.log(writeFileSync(dist, result))\r\n}",
    "mapping": {},
    "path": "{voice}/lib/genWav.js"
  },
  "{A129D0C3-5203-49A9-8059-374AB359B604}": {
    "source": "// imports OLE\r\nconst sapi = require(\"SAPI.SpVoice\")\r\n\r\n// imports built-ins\r\nconst { Enumerator } = require('JScript')\r\n\r\n// imports libraries\r\nconst { initServer, getServer, serverError } = require('./server')\r\nconst request = require('./request')\r\n\r\n// exports\r\nmodule.exports = {\r\n    getVoices,\r\n    getVoiceID\r\n}\r\n\r\n/** @typedef {Number} Int */\r\n/**\r\n * Get the list of voice objects available in \"SAPI.SpVoice\".\r\n * @example\r\n * getVoices(\"Language=411\") // japanese\r\n * // Gender (select Male / Female)\r\n * // Age (Adult only)\r\n * // Name (Haruka etc.)\r\n * // Language\t(411 etc.)\r\n * // Vendor (Microsoft etc.)\r\n * @param {String} option\r\n * @returns\r\n */\r\nfunction getVoices(option) {\r\n    const voices = {}\r\n    new Enumerator(sapi.GetVoices(option))\r\n        .forEach(voice => {\r\n            const name = voice.GetAttribute(\"Name\")\r\n            const names = name.split(/\\s+/)\r\n            const vender = names[0]\r\n            const status = names[names.length - 1]\r\n            const charactor = name.slice(vender.length, status.length * -1).trim()\r\n\r\n            voices[name] = voice\r\n            voices[vender] = voices[vender] || {}\r\n            voices[vender][charactor] = voices[vender][charactor] || {}\r\n            voices[vender][charactor][status] = voice\r\n        })\r\n    return voices\r\n}\r\n\r\n/**\r\n * Returns the VOICEVOX speaker ID from an audio object.\r\n * @example\r\n * const { speach, getVoices, getVoiceID } = require('voice')\r\n * speach('何やら外が騒がしいぞ', { speaker: getVoiceID('九州そら','ささやき') })\r\n * @param {String} name\r\n * @param {String} type\r\n * @returns {Int} speaker\r\n */\r\nfunction getVoiceID(name, type) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    const speakers = request('GET', 'speakers', {\r\n        headers: {\r\n            accept: 'application/json'\r\n        }\r\n    })\r\n    if (!type) {\r\n        if (!name) return speakers\r\n        else return speakers\r\n            .find(speaker => speaker.name === name)\r\n            .styles\r\n    }\r\n    return speakers\r\n        .find(speaker => speaker.name === name)\r\n        .styles\r\n        .find(style => style.name == type)\r\n        .id\r\n}\r\n",
    "mapping": {},
    "path": "{voice}/lib/getVoices.js"
  },
  "{20049F22-5DC7-401D-98FF-3D55F0122BC1}": {
    "source": "// imports built-ins\r\nconst { resolve } = require('pathname')\r\nconst { existsFileSync } = require('filesystem')\r\n\r\n// imports libraries\r\nconst compile = require('./compile')\r\nconst genQuery = require('./genQuery')\r\nconst genWav = require('./genWav')\r\nconst execute = require('./execute')\r\nconst { initServer, getServer, serverError } = require('./server')\r\n\r\n// exports\r\nmodule.exports = speach\r\n\r\n/** @typedef {Object<string, value>} SpeachOptions */\r\n\r\n/**\r\n *\r\n * @example\r\n * speach('僕はずんだの妖精「ずんだもん！」なのだ')\r\n * @param {String} content\r\n * @param {SpeachOptions?} options\r\n */\r\nfunction speach(content, options = {}) {\r\n    initServer()\r\n    if (!getServer()) throw serverError\r\n\r\n    const { speaker = 1, out = 'audio.wav', transformer = (json) => json } = options\r\n\r\n    let query = transformer(genQuery(content, speaker))\r\n    genWav(query, { speaker, out })\r\n\r\n    const exe = resolve(__dirname, '../', 'player.exe')\r\n    if (!existsFileSync(exe)) compile('player.cs', { target: 'exe', out: 'player.exe' })\r\n\r\n    execute('player.exe ' + out)\r\n}\r\n",
    "mapping": {},
    "path": "{voice}/lib/speach.js"
  },
  "{B5FAD3FA-C939-4ED0-982B-663CDCC2FB11}": {
    "source": "// imports OLE\r\nconst sapi = require(\"SAPI.SpVoice\")\r\n\r\n// exports\r\nmodule.exports = speak\r\n\r\n/** @typedef {Number} Int */\r\n\r\n/**\r\n * @typedef {Object} SpVoice\r\n * @property {SpeechVoiceEvents} AlertBoundary - AlertBoundary () {get} {set}\r\n * @property {Boolean} AllowAudioOutputFormatChangesOnNextSet - AllowAudioOutputFormatChangesOnNextSet () {get} {set}\r\n * @property {ISpeechObjectToken} AudioOutput - AudioOutput () {get} {set by ref}\r\n * @property {ISpeechBaseStream} AudioOutputStream - AudioOutputStream () {get} {set by ref}\r\n * @property {SpeechVoiceEvents} EventInterests - EventInterests () {get} {set}\r\n * @property {SpeechVoicePriority} Priority - Priority () {get} {set}\r\n * @property {Int} Rate - Rate () {get} {set}\r\n * @property {ISpeechVoiceStatus} Status - Status () {get}\r\n * @property {Int} SynchronousSpeakTimeout - SynchronousSpeakTimeout () {get} {set}\r\n * @property {ISpeechObjectToken} Voice - Voice () {get} {set by ref}\r\n * @property {Int} Volume - Volume () {get} {set}\r\n */\r\n\r\n/**\r\n * @typedef {Object} SpeakOptions\r\n * @property {ISpeechObjectToken} Voice\r\n */\r\n\r\n/**\r\n * Output audio using \"SAPI.SpVoice\". You can also select the audio type.\r\n * @example\r\n * const voices = require('./getVoices')()\r\n * speak('ずんだもんなのだ', { Voice: getVoices().VOICEVOX['ずんだもん']['ノーマル'] })\r\n * @param {string} content\r\n * @param {SpeakOptions?} options\r\n */\r\nfunction speak(content, options = {}) {\r\n    Object.keys(options).forEach(attr => sapi[attr] = options[attr])\r\n    sapi.Speak(content)\r\n}",
    "mapping": {},
    "path": "{voice}/lib/speak.js"
  },
  "{3FF77F3C-72D0-4CE3-8594-FA9E44703F09}": {
    "source": "using System.Media;\r\n\r\nclass Program\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        SoundPlayer player = new SoundPlayer(args[0]);\r\n        player.PlaySync();\r\n    }\r\n}",
    "mapping": {},
    "path": "{voice}/player.cs"
  },
  "{2F69894C-61E9-484F-8E7A-43B3A9CB276D}": {
    "source": "const { getVoiceID, getVoices } = require('./lib/getVoices')\r\nconst speak = require('./lib/speak')\r\n\r\nconsole.log(() => getVoiceID())\r\n\r\ngetVoiceID().forEach(character => {\r\n    character.styles.forEach(type => {\r\n        console.log(() => `私の名前は${character.name}。今は${type.name}で話している。`)\r\n        speak(\r\n            `私の名前は${character.name}。今は${type.name}で話している。`,\r\n            { Voice: getVoices().VOICEVOX[character.name][type.name] }\r\n        )\r\n    })\r\n})",
    "mapping": {},
    "path": "{voice}/voices.js"
  },
  "{44B46579-4803-4EF1-8608-DCC1BE5E3559}": {
    "source": "# voice\r\n\r\n*voice* は文字列から声を生成する [*wes*][wes] 用のモジュールになります。\r\n\r\n## install\r\n\r\nインストールには [*wes*][wes] が必要になります。\r\n\r\n```batch\r\nwes install @wachaon/voice --bare\r\n```\r\n\r\n## usage\r\n\r\n一番シンプルな用法になります。\r\n\r\n```javascript\r\nconst { speak } = require('voice')\r\nspeak('こんにちは 世界')\r\n```\r\n\r\n`speak()` は *SAPI.SpVoice* を利用して話します。\r\n第2引数に声色を設定できます。\r\n\r\n```javascript\r\nconst { speak, getVoices } = require('voice')\r\nspeak('こんにちは 世界', { Voice: getVoices().Microsoft.Haruka.Desktop })\r\n```\r\n\r\n## VOICEVOX 連携\r\n \r\n[*VOICEVOX*][VOICEVOX] と連携することによってより多くの声色に対応できます。\r\n逆に `speak()` 以外のメソッドは [*VOICEVOX*][VOICEVOX] のインストールが必要になります。\r\n\r\n`speak()` で声色を変更するには [*VOICEVOX*][VOICEVOX] と [*SAPIForVOICEVOX*][SAPIForVOICEVOX] の両方をイントールしてください。([*SAPIForVOICEVOX*][SAPIForVOICEVOX] は *64bit* 版をインストールしてください。)\r\n\r\n## usage\r\n\r\nシンプルな方法での声色変更です。\r\n\r\n```javascript\r\nconst { speak, getVoices } = require('voice')\r\nspeak('こんにちは 世界なのだ', { Voice: getVoices().VOICEVOX['ずんだもん']['ヒソヒソ'] })\r\n```\r\n\r\n## VOICEVOX ENGINE\r\n\r\n[*VOICEVOX*][VOICEVOX] をインストールすれば *VOICEVOX ENGINE* を利用することで、\r\n細やかな制御を行うことが可能です。\r\n\r\n*VOICEVOX ENGINE* を利用する流れ\r\n\r\n1. *audio_query* の生成\r\n2. *audio_query* から *audio.wav* ファイルを生成\r\n3. *audio.wav* ファイルを [*wes*][wes] から再生できるように *player.exe* を生成\r\n4. *player.exe* 利用し、 *audio.wav* を再生\r\n\r\n`speaker` は声色のIDになります。\r\n\r\n```javascript\r\nconst { speach, getVoiceID } = require('voice')\r\nspeach('こんにちは 世界よ', { speaker: getVoiceID('あいえるたん', 'ノーマル') })\r\n```\r\n\r\n*speaker* の一覧はコマンドで呼び出せます\r\n\r\n```javascript\r\nconst { getVoiceID } = require('/index')\r\nconsole.log(() => getVoiceID())\r\n```\r\n\r\nまた、[*VOICEVOX*][VOICEVOX] の声色は以下で確認できます。\r\n\r\n```batch\r\nwes voices\r\n```\r\n\r\n[wes]: <https://github.com/wachaon/wes/>\r\n[VOICEVOX]: <https://voicevox.hiroshiba.jp/>\r\n[SAPIForVOICEVOX]: <https://github.com/shigobu/SAPIForVOICEVOX/>",
    "mapping": {},
    "path": "{voice}/README.md"
  },
  "{516E3612-E262-45D4-A541-6FEAF059971E}": {
    "source": "MIT License\r\n\r\nCopyright (c) 2024 wachaon\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n",
    "mapping": {},
    "path": "{voice}/LICENSE"
  }
}